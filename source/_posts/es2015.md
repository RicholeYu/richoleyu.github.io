---
title: es2015
date: 2019-11-20 22:00:05
tags:
---
## ES2015新语法
  
* [let、const和块级作用域](#let、const和块级作用域)
* [Map、Set](#Map、Set)
* [for of 循环、iterable类型](#for-of循环、iterable类型)
* [箭头函数（Arrow Function）](#箭头函数)
* [模板字符串（Template String）](#模板字符串)
* [对象字面量扩展语法（Enhanced Object Literals）](#对象字面量扩展语法)
* [表达式结构（Destructuring）](#表达式结构)
* [函数参数表达、传参](#函数参数表达、传参)
* [新的数据结构](#新的数据结构)
* [类（Classes）](#类)
* [生成器（Generator）](#生成器)
* [Promise](#Promise)
* [代码模块化](#代码模块化)
* [Symbol](#Symbol)
* [Proxy](#Proxy)

## let、const和块级作用域
let const可用于块级作用域, 与var相比let不能被状态提升和重复定义  
### 从工程化角度, 应该在ES6以上标准中遵循以下三条原则:  
1. 一般情况下, 使用const来定义常量
2. 只有在值确定会被改变时才使用let来定义变量
3. 不使用var
---
## Map、Set
ES2015提供了新的数据结构**Set**、**WeakSet**和**Map**、**WeakMap**
  
**Set**类似于数组, 但是成员的值是唯一不重复的, 可以接受一个数组（或者具有iterable接口的其他数据结构）作为参数来初始化
  
**WeakSet**和**Set**相似, 唯一区别是**WeakSet**不可以遍历, 也没有size变量, 因为成员都是弱引用, 不会被记入内存回收机智, 适合存储DOM节点或实例变量, 当节点或变量被回收后, 成员会被删除, 不用担心引发内存泄漏  
  
**Map**解决了传统Javascript对象只能用字符串作为建, Map类似于对象, 也是键值对的集合, 但是键的范围不限于字符串, 各种类型的值（包括对象）都可以当做键  
也就是说, Object结构提供了"字符串-值"的对应, Map结构提供了"值-值"的对应, 是一种更完善的Hash结构实现

**WeakMap**与**Map**相似, 与Map不同的是, WeakMap只接受对象作为键名（不包括null）


**WeakMap**的设计目的在于, 有时我们想在某个对象上面存放一些数据, 但是由于Map对这些对象的引用, 而无法进行垃圾回收, 存在内存泄漏, 跟**WeakSet**一样, **WeakSet**也没有size变量, 不可遍历
#### 实例属性和操作方法
Set.prototype.size: 返回Set成员总数
Set.prototype.add(value): 添加值, 返回Set实例
Set.prototype.delete(value): 删除值, 返回布尔值, 表示删除是否成功
Set.prototype.has(value): 返回布尔值, 表示该值是否为Set成员
Set.prototype.clear(): 清除所有成员, 没有返回值
  
WeakSet.prototype.add(value): 添加值
WeakSet.prototype.delete(value): 删除值
WeakSet.prototype.has(value): 返回布尔值, 表示该值是否为WeakSet成员
  
Map.prototype.size: 返回Map成员总数
Map.prototype.set(key, value): 添加键值对
Map.prototype.get(key): 获取键值对
Map.prototype.has(key): 返回布尔值, 表示是否含有这个key
Map.prototype.delete(key): 删除键值对
Map.prototype.clear(): 清空Map成员

WeakMap.prototype.set(key, value): 添加键值对
WeakMap.prototype.get(key): 获取键值对
WeakMap.prototype.has(key): 返回布尔值, 表示是否含有这个key
WeakMap.prototype.delete(key): 删除键值对
```javascript
const a = new Set(['a','b', 1, 1, 4])
console.log(a.size)
// 4

const b = new Set(document.querySelectorAll('div'))
console.log(b.size)
// ...

// 数组去重
[...new Set([1, 1, 2, 2])]
Array.from(new Set([1, 1, 2, 2]))

// 去除字符串重复字符
[...new Set(['ababbc'])].join(')
// "abc"

const foos = new WeakSet()
class Foo {
     constructor () {
          foos.add(this)
     }
     method () {
       if (!foos.has(this)) {
            throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');
       }
     }
}

const map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);

map.size // 2
map.has('name') // true
map.get('name') // "张三"
map.has('title') // true
map.get('title') // "Author"
```
## for-of循环、iterable类型
遍历Array可以使用下标循环, 遍历Map和Set就无法使用下标循环了  
为了统一集合类型, ES2015引入了新的iterable类型, Array、Map、和Set都属于iterable类型, 可以用于for of循环
iterable内置了forEach方法, 可使用forEach方法进行循环
for of可代替for in循环语句, 配合块级作用域某些情况可以代替Array.map 和 Array.forEach  
```javascript
const a = ['A', 'B', 'C'];
const s = new Set(['A', 'B', 'C']);
const m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
// 遍历Array
for (var x of a) {
    console.log(x);
}
// 遍历Set
for (var x of s) {
    console.log(x);
}
// 遍历Map
for (var x of m) {
    console.log(x[0] + '=' + x[1]);
}

const arr = [1, 2, 3]
const message = [{
    text: 'hello world',
    id: 1
}, {
    text: 'hello china',
    id: 2
}, {
    text: 'hello chinese',
    id: 3
}]

for (const item of arr) {
    console.log(item)
}
// 1
// 2
// 3
for (const {text, id} of message) {
    setTimeout(() => console.log(text, id), 100)
}
// hello world 1
// hello china 2
// hello chinese 3

for (var value in message) {
    setTimeout(() => console.log(message[value], value), 100)
}
// {text: "hello chinese", id: 3} "2"
// {text: "hello chinese", id: 3} "2"
// {text: "hello chinese", id: 3} "2"
```
---
## 箭头函数
箭头函数属于匿名函数一类, 简化了匿名函数定义, 箭头函数内部的this是词法作用域, 由上下文确定  
call 和 apply 无法对箭头函数的this进行绑定, 传入的第一个参数会被忽略
```javascript
let obj = {
    birth: 1903,
    getAge (year) {
        let b = this.birth
        let fn = y => y - this.birth
        return fn.call({birth: 2000}, year)
    }
}
obj.getAge(2019)
// 26
```
---
## 模板字符串
模板字符串支持元素注入、支持换行
```javascript
const name = 'richole'
const message = `
hello 
${name}
`
```
---
## 对象字面量扩展语法
1. 函数类属性的省略写法
```javascript
const obj = {
    // before
    foo: function () {
        return 'foo'
    },
    // after
    boo () {
        return 'boo'
    }
}
```  
2. 支持__proto__注入
ES2015 开发了向对象字面量注入__proto__的功能, 使得开发者得到更高的操作权限, 从而更加灵活地创建和操作对象  
在ES2015标准中, 开发者允许直接向一个对象字面量注入__proto__  
使其直接成为指定类的一个实例, 无需另外创建一个类实现继承
```javascript
var c = {
    a: 1,
    __proto__: new Date()
}
console.log(c instance of Date)
// true
```
3. 可动态计算的属性名
```javascript
const prefix = 'hello'
const obj = {
    [`${prefix} world`]: true
}
```
4. 讲属性名定义省略
```javascript
const foo = 123
const boo = () => console.log('boo)
const obj = {
    foo,
    boo
}
```
---
## 表达式结构